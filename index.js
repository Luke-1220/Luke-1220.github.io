var data = [
{
url: "https://luke1220.tk/post/",
title: "Posts",
ctime: "20200804",
content: "[]"
}
,{
url: "https://luke1220.tk/post/lastmod/",
title: "【Hugo】Robustテーマで記事を更新順に並べる",
ctime: "20200804",
content: "[HugoのRobustテーマで記事を更新順に並べ、記事一覧に更新日を表示させる方法を紹介します。 はじめに Qiitaから引っ越した記事などにdateとlastmodを設定したのですが、記事一覧が作成日順になっているのが気になりました。 もし、昔書いた記事を大幅に書き換えて最新の内容にしたのに、作成日が古いせいで後ろの方に表示される、なんてことがあったら困ります。 そこで今回は、記事を更新順に並べてみます。 記事を更新順に並べる themes/hugo_theme_robust/layouts/_default/list.htmlを、layouts/_default/list.htmlにコピー。 1{{ range $paginator.Pages }} この部分（⌘Fで探してください）に書き足すだけです。 1{{ range $paginator.Pages.ByLastmod.Reverse }} .ByLastmodで更新日の古い順にし、.Reverseで新しい順に並び替えます。 追記 結局、記事一覧の方は作成日順に戻しました。 更新順にするのはLATESTSだけで良いかな…。 記事一覧に更新日を表示させる themes/hugo_theme_robust/layouts/_default/li_sm.htmlもlayouts/_default/li_sm.htmlにコピーします。 li_sm.htmlとlist.htmlから以下の一行を探し、 1&amp;lt;li&amp;gt;&amp;lt;i class=&amp;#34;fas fa-calendar&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;time datetime=&amp;#34;{{ .Date.Format &amp;#34;2007-01-02T15:04:05JST&amp;#34; }}&amp;#34;&amp;gt;{{ .Date.Format ( .Site.Params.dateformat | default &amp;#34;Jan 2, 2006&amp;#34;) }}&amp;lt;/time&amp;gt;&amp;lt;/li&amp;gt; 削除してから、このif文を丸ごとペーストしてください。 1{{ if ne .Date .Lastmod }} 2&amp;lt;li&amp;gt;&amp;lt;i class=&amp;#34;fas fa-sync&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;time datetime=&amp;#34;{{ .Lastmod.Format &amp;#34;2006-01-02T15:04:05JST&amp;#34; }}&amp;#34;&amp;gt;{{ .Lastmod.Format ( .Site.Params.dateformat | default &amp;#34;Jan 2, 2006&amp;#34;) }}&amp;lt;/time&amp;gt;&amp;lt;/li&amp;gt; 3{{ else }} 4&amp;lt;li&amp;gt;&amp;lt;i class=&amp;#34;fas fa-calendar&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;time datetime=&amp;#34;{{ .Date.Format &amp;#34;2006-01-02T15:04:05JST&amp;#34; }}&amp;#34;&amp;gt;{{ .Date.Format ( .Site.Params.dateformat | default &amp;#34;Jan 2, 2006&amp;#34;) }}&amp;lt;/time&amp;gt;&amp;lt;/li&amp;gt; 5{{ end }} これで、更新日がある場合はそちらが表示され、ない場合（または作成日と同じ場合）は作成日が表示されます。 ちなみに、li_sm.htmlがサイドバーの「LATESTS」や記事ページ下部の「次の記事」欄のHTMLファイルで、list.htmlはトップページやカテゴリページのためのHTMLファイルのようです。 参考 最近更新された記事（新着記事）のリストを表示する]"
}
,{
url: "https://luke1220.tk/post/get-related-articles/",
title: "【Swift5】キーワードの重複で「関連記事」を取得してみる",
ctime: "20200607",
content: "[今回は、ニュースアプリの記事ページの一番下にある「関連記事」を選ぶ関数を作ったので共有したいと思います。 使用するクラス 1class Entry: NSObject, NSCoding { 2 var title:String? 3 //省略 4} 自分のアプリでは、titleの他にURLなどのプロパティも持たせています。 完成品 1func getRelatedArticle(entry:Entry, entries:[Entry]) -&amp;gt; [Entry] { 2 3 let exempt = [&amp;#34;で&amp;#34;,&amp;#34;の&amp;#34;,&amp;#34;は&amp;#34;,&amp;#34;を&amp;#34;,&amp;#34;も&amp;#34;,&amp;#34;が&amp;#34;,&amp;#34;に&amp;#34;,&amp;#34;万&amp;#34;,&amp;#34;円&amp;#34;] 4 var words:[String] = [] 5 var counts:Dictionary&amp;lt;Entry,Int&amp;gt; = [:] 6 let checkEntries = entries.filter {$0 != entry} 7 8 let wordTokenizer = NLTokenizer(unit: .word) 9 wordTokenizer.string = entry.title 10 wordTokenizer.enumerateTokens(in: entry.title!.startIndex..&amp;lt;entry.title!.endIndex) { tokenRange, _ in 11 let word = String(entry.title![tokenRange]).localizedUppercase 12 if !exempt.contains(word) { 13 words.append(word) 14 print(word) 15 } 16 return true 17 } 18 //print(&amp;#34;contains:\(words)&amp;#34;) 19 20 for e in checkEntries { 21 var count = 0 22 let text = e.title! 23 wordTokenizer.string = text 24 wordTokenizer.enumerateTokens(in: text.startIndex..&amp;lt;text.endIndex) { tokenRange, _ in 25 //print( text[tokenRange]) 26 if words.contains(String(text[tokenRange].localizedUppercase)) { 27 count &#43;= 1 28 } 29 return true 30 } 31 counts.updateValue(count, forKey: e) 32 } 33 let sorted = Array(counts).sorted {$0.1 &amp;gt; $1.1}.prefix(3) 34 var related:[Entry] = [] 35 for (key,value) in (sorted) { 36 //print(&amp;#34;\(key.title!) 単語数:\(value)&amp;#34;) 37 related.append(key) 38 } 39 return related 40} 全ての記事名を単語に分解して、重複する単語が多かった記事を関連記事として選んでいます。 分解には標準ライブラリのNaturalLanguageを使っているので忘れずにimportしてください。 1import NaturalLanguage 使用例 1//nowEntry -&amp;gt; 今見ている記事 2//AllEntries -&amp;gt; 全ての記事の配列 3let related = getRelatedArticle(entry: nowEntry, entries: AllEntries) 4print(related.map({$0.title!})) 出力結果 この記事で実験してみました。 また、全記事のリストはいくつかニュースサイトのRSSから取得しています。 藤井七段「充実感が…」棋聖戦第一局に勝利 コメントアウトしてあるprintを使えばログで確認できます。 抽出した単語と、関連記事はこんな感じになりました。 contains:[&amp;quot;藤井&amp;quot;, &amp;quot;七&amp;quot;, &amp;quot;段&amp;quot;, &amp;quot;充実&amp;quot;, &amp;quot;感&amp;quot;, &amp;quot;棋聖&amp;quot;, &amp;quot;戦&amp;quot;, &amp;quot;第&amp;quot;, &amp;quot;一&amp;quot;, &amp;quot;局&amp;quot;, &amp;quot;勝利&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;21&amp;quot;, &amp;quot;33&amp;quot;, &amp;quot;更新&amp;quot;] 藤井七段、棋聖戦第一局で渡辺三冠に勝利 6/8 20:08更新 単語数:12 藤井七段が最年少で挑戦 「棋聖戦」始まる 6/8 12:05更新 単語数:8 経団連会長 第２次補正予算案を評価 6/8 21:48更新 単語数:5 藤井七段の他の記事は取得できているので、問題ありません。 ただ、やっぱり精度が微妙なので「この記事もオススメ」みたいな感じで表示させた方がいいかも。 補足、解説 1let exempt = [&amp;#34;で&amp;#34;,&amp;#34;の&amp;#34;,&amp;#34;は&amp;#34;,&amp;#34;を&amp;#34;,&amp;#34;も&amp;#34;,&amp;#34;が&amp;#34;,&amp;#34;に&amp;#34;,&amp;#34;万&amp;#34;,&amp;#34;円&amp;#34;] ここで除外する単語を指定しています。 英語のサイトでは「a」「the」「in」などのワードが余計でした。 後々、ひらがな一文字とアルファベット一文字を自動で除外できるようにしたい。 1for (key,value) in (Array(counts).sorted {$0.1 &amp;gt; $1.1}.prefix(3)) { 2 //print(&amp;#34;\(key.title!) 単語数:\(value)&amp;#34;) 3 related.append(key) 4} ここのprefix(3)を変更することで取得する記事の数が変更できます。 課題 この記事のタイトルのように括弧などの記号などが含まれていると単語が取得できない 参考 https://dev.classmethod.jp/articles/ios12-natural-language-tokenizing/]"
}
,{
url: "https://luke1220.tk/post/pre-fill-form/",
title: "【Swift5】Googleフォームにあらかじめ自動入力する",
ctime: "20200525",
content: "[アプリの不具合の報告などで、OS情報やアプリのバージョンなどの情報があるととても助かりますよね。 そこで今回は、それらの項目を自動入力してくれるフォームの作り方を紹介します。 方法 Googleフォームには、自動入力済みのURLを発行する機能があります。 このURLの一部をSwiftで書き換えればいいのです。 1. フォームを作成 こちらからフォームを作成してください。 作成方法については説明を割愛させていただきます。 2. URLを生成 フォーム作成画面の右上にある、・が縦に3つ並んだメニューボタンから、「事前入力したURLを取得」をクリックします。 するとフォーム入力画面に飛ぶので、事前入力しておきたい項目に分かりやすい文字列を入力しておきます。 「リンクを取得」をクリックするとURLが生成されます。 画面左下の「リンクをコピー」を押してコピーしておきましょう。 自分の場合はこのようなリンクになりました。 https://docs.google.com/forms/d/e/1FAIpQLScUGRP-Pbs0bpBw2MtwjN6OpxeoHgUjloGV-OMNVOBvEkLJ6A/viewform?usp=pp_url&amp;amp;entry.1009686721=osversion&amp;amp;entry.1835889012=appversion 3. OS情報、アプリのバージョンを取得 OS名はUIDevice.current.systemName、OSバージョンはUIDevice.current.systemVersionで取得可能です。（どちらもStringです） 1let os = &amp;#34;\(UIDevice.current.systemName)%20\(UIDevice.current.systemVersion)&amp;#34; 2let version = Bundle.main.object(forInfoDictionaryKey: &amp;#34;CFBundleShortVersionString&amp;#34;) as? String この文字列はURLの一部となるため、スペース（空白）は使ってはいけません。 代わりに%20を使用すると空白になります。 追記 機種の名前を取得する 正確な機種名（例えば「iPhone XS」など）を取得するため、YMTGetDeviceNameというライブラリを使用します。 1var device = YMTGetDeviceName.share.getDeviceName() 2if let devName = device.range(of: &amp;#34; &amp;#34;) { 3 device.replaceSubrange(devName, with: &amp;#34;%20&amp;#34;) 4} rangeを使って、空白を%20に置き換えています。 4. URLの書き換え 先ほどのURLのosversionの部分を\(os)に、appversionの部分を\(version)に書き換えるだけです。 1let url = URL(string:&amp;#34;https://docs.google.com/forms/d/e/1FAIpQLScUGRP-Pbs0bpBw2MtwjN6OpxeoHgUjloGV-OMNVOBvEkLJ6A/viewform?usp=pp_url&amp;amp;entry.1009686721=\(os)&amp;amp;entry.1835889012=\(version!)&amp;#34;) 2UIApplication.shared.open(url! as URL) 動作確認 問題なく表示されています。 ユーザーの手間を省けるので、試す価値はあると思います！]"
}
,{
url: "https://luke1220.tk/post/original-class-save/",
title: "【Swift5】自作クラス（と配列）をUserDefaultsに簡単に保存する",
ctime: "20200524",
content: "[この記事では自作クラスをUserDefaultsに簡単に保存する関数を紹介します。 ちょっとしたデータの保存はUserDefaultsを使うのが一般的ですが、保存できる型が限られています。 対応していない場合はDataに変換して保存する必要があり、少し面倒です。 そこで今回は関数（と言っても大したことはないですが）を作成しました。 保存したいクラス 1 class Friend: NSObject, NSCoding { 2 var name:String? 3 var age:Int? 4 5 init(_ name: String?, _age: Int?) { 6 self.name = name 7 self.age= age 8 } 9 10 func encode(with coder: NSCoder) { 11 coder.encode(name, forKey: &amp;#34;name&amp;#34;) 12 coder.encode(age, forKey: &amp;#34;age&amp;#34;) 13 } 14 15 required init?(coder: NSCoder) { 16 name = coder.decodeObject(forKey: &amp;#34;name&amp;#34;) as? String 17 age = coder.decodeObject(forKey: &amp;#34;age&amp;#34;) as? Int 18 } 19 } ポイントは１行目に: NSObject, NSCodingと加えることと、エンコード・デコードの部分を用意することです。 保存、取得用の関数 通常 1 extension UserDefaults { 2 func getFriend(_ key:String) -&amp;gt; Friend? { 3 if let storedData = UserDefaults.standard.object(forKey: key) as? Data { 4 if let unarchivedObject = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(storedData) as? Friend { 5 return unarchivedObject 6 } 7 } 8 return nil 9 } 10 11 func setFriend(_ friend:[Friend],_ key:String) { 12 let data = try! NSKeyedArchiver.archivedData(withRootObject: friend, requiringSecureCoding: false) 13 UserDefaults.standard.set(data, forKey: key) 14 } 15 } 配列の場合 1 extension UserDefaults { 2 func getFriends(_ key:String) -&amp;gt; [Friend]? { 3 if let storedData = self.object(forKey: key) as? Data { 4 if let unarchivedObject = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(storedData) as? [Friend] { 5 return unarchivedObject 6 } 7 } 8 return nil 9 } 10 11 func setFriends(_ friends:[Friend],_ key:String) { 12 let data = try! NSKeyedArchiver.archivedData(withRootObject: friends, requiringSecureCoding: false) 13 self.set(data, forKey: key) 14 } 15 } 使用方法 この関数はUserDefaultsの拡張なので、このように使います。 通常 1 let boy = Friend.init(&amp;#34;Tom&amp;#34;,25) 2 //保存 3 UserDefaults.standard.setFriend(boy,&amp;#34;friend&amp;#34;) 4 //取得 5 let friend = UserDefaults.standard.getFriend(&amp;#34;friend&amp;#34;) 配列の場合 1 let boys = [Friend.init(&amp;#34;Tom&amp;#34;,25),Friend.init(&amp;#34;Bob&amp;#34;,18)] 2 //保存 3 UserDefaults.standard.setFriends(boys,&amp;#34;friends&amp;#34;) 4 //取得 5 let friends = UserDefaults.standard.getFriends(&amp;#34;friends&amp;#34;) おわりに 通常のUserDefaultsのように１行で使えるので、コードが見やすくなると思います。 間違っている部分があったら教えていただけると助かります🙇‍♂️]"
}]
