var data = [




{
url: "https://luke-1220.github.io/post/search/",
title: "【Hugo】サイト内検索機能を実装した",
ctime: "2020/11/23",
content: "[Clarityテーマで作り直した新しいサイトに、検索機能を追加しました。 はじめに 右側のサイドバー（スマホだとこの記事の下）に、「search」というバーがあります。 ここに入力してエンターキーを押すと、新しく作成した検索用ページに飛びます。 複数ワードの検索など賢いことはできませんが、検索結果の読み込みが速く、あまり負荷もかかりません。 今回はこれの作り方をざっと説明していきます。 自分はHTMLもJSも初心者のため、間違っているところや書き直した方がいい表記があればご指摘お願いします🙇‍♂️ 参考 Hugoに全文検索を取り付けた JavaScriptにBlogの全文検索をやらせてみる 下のサイトはHugoではないですが、上のサイトの方法ではコードがほぼそのまま流用されていました。 ここで紹介するのは、それにいくつか機能を追加したものです。 手順 1.検索用データベースを作成 まずは検索用データベースとして使う、jsの配列ファイルを用意します。 Hugoならではの方法だと思いますが、記事ファイルを利用して作成することにします。 MarkDownを用意 content/indexjs.mdを作成し、以下をコピーしてください。 1--- 2date: 2020-11-22T15:04:16&#43;09:00 3type: &amp;#34;js&amp;#34; 4url: &amp;#34;index.js&amp;#34; 5--- HTMLを用意 次に、layouts/js/single.htmlを作成します。 1var data = [{{ range $index, $page := where .Site.Pages &amp;#34;Section&amp;#34; &amp;#34;post&amp;#34;}} 2{{ if ne $page.Title &amp;#34;Posts&amp;#34; }} 3{{ if ne $index 1 }},{{ end }} 4{ 5url: &amp;#34;{{ $page.Permalink }}&amp;#34;, 6title: &amp;#34;{{ $page.Title }}&amp;#34;, 7ctime: &amp;#34;{{ $page.Date.Format &amp;#34;20060102&amp;#34; }}&amp;#34;, 8content: &amp;#34;{{ .PlainWords }}&amp;#34; 9} 10{{ end }} 11{{ end }}] 構造 先ほどのMarkDownでtypeをjsに指定しているので、layouts/js下のHTMLが読み込まれます。 そしてこのJavaScriptにしか見えないHTMLが読み込まれ、ファイル名がMarkDownで指定されたindex.jsになるわけです。 補足 ちなみに、参考サイトにあるコードに少し手を加えていますが、それは以下のような謎の要素が生成されるのを防ぐためです。 1{ 2url: &amp;#34;https://luke1220.tk/post/&amp;#34;, 3title: &amp;#34;Posts&amp;#34;, 4ctime: &amp;#34;20200804&amp;#34;, 5content: &amp;#34;[]&amp;#34; 6} 2.検索ページを作成 検索ページは一応記事ページということになっているので、まずはsearch.mdという名前で記事を作成しました。 1--- 2title: &amp;#34;Search&amp;#34; 3date: 2020-11-22T15:07:31&#43;09:00 4type: &amp;#34;search&amp;#34; 5--- 後からこのページのHTMLを変更してしまうので、情報はこれだけでいいです。 記事の内容も要りません。 この後、MarkDownにそのまま検索用のJavaScriptを貼り付けるという手もありますが、 それだとうまく動かないので別の方法をとります。 3.検索ページのHTMLファイルを用意 layouts/search/single.htmlを作成。 テーマによって異なりますが、記事ページのHTMLがthemes/テーマ名/layouts/_default/single.html等あると思いますので その内容をコピーして来てください。 その中の記事が表示される部分を削除して、代わりにこの検索用のHTMLを追加していってください。 データベースを読み込み 絶対URLを書くのは嫌なので、Hugoの機能（GoLang表記）を利用してみました。 1&amp;lt;script src=&amp;#39;{{ absURL &amp;#34;index.js&amp;#34; }}&amp;#39;&amp;gt;&amp;lt;/script&amp;gt; 検索用のdivを用意 参考サイトではdl dtタグを使用していましたが、ここではテーマの記事リストっぽいデザインにするために、 ul liタグを使います。 また、エンターキーや矢印キーでページを切り替える機能も要らないので取ってしまいました。 1&amp;lt;div id=&amp;#34;searchbox&amp;#34;&amp;gt; 2 &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;input&amp;#34; onkeyup=&amp;#34;do_find(this.value)&amp;#34; autocomplete=&amp;#34;off&amp;#34; autofocus&amp;gt; 3 &amp;lt;span id=&amp;#34;stat&amp;#34;&amp;gt;&amp;lt;/span&amp;gt; 4&amp;lt;/div&amp;gt; 5&amp;lt;ul class=&amp;#34;posts&amp;#34; id=&amp;#34;result&amp;#34;&amp;gt;&amp;lt;/ul&amp;gt; 6&amp;lt;div id=&amp;#34;navi&amp;#34;&amp;gt;&amp;lt;/div&amp;gt; JavaScriptを用意 かなり長いので、とりあえずコピペしてください。 解説や変更点は次に書きます。 (↓折りたたまれているのでご注意ください) 1&amp;lt;script&amp;gt; 2{ 3 $_ = String.prototype; 4 5 $_.mReplace = function(pat,flag){ 6 var temp = this; 7 if(!flag){flag=&amp;#34;&amp;#34;} 8 for(var i in pat){ 9 var re = new RegExp(i,flag); 10 temp = temp.replace(re,pat[i]) 11 } 12 return temp; 13 }; 14} 15 16{ 17 $_ = Date.prototype; 18 19 $_.format = &amp;#34;yyyy-mm-dd HH:MM:SS&amp;#34;; 20 $_.formatTime = function(format){ 21 var yy; 22 var o = { 23 yyyy : ((yy = this.getYear()) &amp;lt; 2000)? yy&#43;1900 : yy, 24 mm : this.getMonth() &#43; 1, 25 dd : this.getDate(), 26 HH : this.getHours(), 27 MM : this.getMinutes(), 28 SS : this.getSeconds() 29 } 30 for(var i in o){ 31 if (o[i] &amp;lt; 10) o[i] = &amp;#34;0&amp;#34; &#43; o[i]; 32 } 33 return (format) ? format.mReplace(o) : this.format.mReplace(o); 34 } 35} 36&amp;lt;/script&amp;gt; 37&amp;lt;script&amp;gt; 38var bodylist = []; 39var st = gid(&amp;#34;stat&amp;#34;); 40var re = gid(&amp;#34;result&amp;#34;); 41var nv = gid(&amp;#34;navi&amp;#34;); 42var max = 5; 43function gid(id){ 44 return document.getElementById(id); 45} 46function ignore_case(){ 47 var a = arguments; 48 return &amp;#34;[&amp;#34; &#43; a[0] &#43; a[0].toUpperCase() &#43; &amp;#34;]&amp;#34; 49} 50function do_find(v){ 51 const input = document.getElementById(&amp;#34;input&amp;#34;) 52 window.history.replaceState(0, 0,&amp;#34;./?q=&amp;#34;&#43;input.value); 53 54 if(this.lastquery == v){return} 55 this.lastquery = v; 56 var re = find(v); 57 if(re.length){ 58 pagenavi(re); 59 view(re) 60 } 61} 62function find(v){ 63 var query = v; 64 if(!v){return []} 65 var aimai; 66 if(query){ 67 68 69 aimai = query.replace(/[a-z]/g,ignore_case); 70 try{ 71 reg = new RegExp(aimai,&amp;#34;g&amp;#34;); 72 }catch(e){ 73 reg = /(.)/g; 74 } 75 }else{ 76 reg = /(.)/g; 77 } 78 var result = []; 79 for(var i=0;i&amp;lt;data.length;i&#43;&#43;){ 80 81 var s = bodylist[i]; 82 var res = reg.exec(s); 83 if(!res){continue} 84 var len = res[0].length; 85 var idx = res.index; 86 if(idx != -1){ 87 result.push([i,idx,len]); 88 } 89 } 90 if(result.length){ 91 st.innerHTML = result.length &#43;&amp;#34; / &amp;#34;&#43; data.length; 92 } 93 return result; 94} 95function snippet(body,idx,len){ 96 var start = idx - 20; 97 return [ 98 body.substring(start,idx), 99 ,&amp;#34;&amp;lt;b&amp;gt;&amp;#34; 100 ,body.substr(idx,len) 101 ,&amp;#34;&amp;lt;/b&amp;gt;&amp;#34; 102 ,body.substr(idx&#43;len,50), 103 ,&amp;#34;...&amp;#34; 104 ].join(&amp;#34;&amp;#34;); 105} 106function pagenavi(result){ 107 var len = result.length; 108 var ct = Math.ceil(len/max); 109 var buf = []; 110 for(var i=0;i&amp;lt;ct;i&#43;&#43;){ 111 buf.push( 112 &amp;#34;&amp;lt;span onclick=&amp;#39;view(\&amp;#34;\&amp;#34;,&amp;#34; 113 ,i&#43;1 114 ,&amp;#34;);sw(&amp;#34;,i,&amp;#34;)&amp;#39;&amp;gt;&amp;#34; 115 ,i&#43;1 116 ,&amp;#34;&amp;lt;/span&amp;gt;&amp;#34; 117 ); 118 } 119 nv.innerHTML = buf.join(&amp;#34;&amp;#34;); 120 sw(0); 121} 122function sw(t){ 123 var span = nv.getElementsByTagName(&amp;#34;span&amp;#34;); 124 for(var i=0;i&amp;lt;span.length;i&#43;&#43;){ 125 span[i].className = (i==t)?&amp;#34;selected&amp;#34;:&amp;#34;&amp;#34;; 126 } 127} 128function mv(to){ 129 var span = nv.getElementsByTagName(&amp;#34;span&amp;#34;); 130 var current; 131 if(!span.length){return} 132 for(var i=0;i&amp;lt;span.length;i&#43;&#43;){ 133 if(span[i].className == &amp;#34;selected&amp;#34;){ 134 current = i;break; 135 } 136 } 137 var moveto = current&#43;to; 138 if(moveto &amp;lt; 0){return} 139 if(moveto &amp;gt; span.length-1){moveto=0} 140 sw(moveto); 141 view(&amp;#34;&amp;#34;,moveto&#43;1) 142} 143function view(result,offset){ 144 if(!offset){offset = 1} 145 if(!result){ 146 result = this.last.reverse(); 147 }else{ 148 this.last = result; 149 } 150 var r = result.reverse(); 151 var buf = [&amp;#34;&amp;lt;dl&amp;gt;&amp;#34;]; 152 var count = 0; 153 for(var i=(offset-1)*max;i&amp;lt;r.length;i&#43;&#43;){ 154 count&#43;&#43;; 155 if(count &amp;gt; max){break} 156 var num = r[i][0]; 157 var idx = r[i][1]; 158 var len = r[i][2]; 159 with(data[num]){ 160 buf.push( 161 &amp;#34;&amp;lt;li class=&amp;#39;post_item&amp;#39;&amp;gt;&amp;lt;div class=&amp;#39;excerpt&amp;#39;&amp;gt;&amp;lt;div class=&amp;#39;excerpt_header&amp;#39;&amp;gt;&amp;lt;a href=&amp;#39;&amp;#34;,url,&amp;#34;&amp;#39;&amp;gt;&amp;lt;h3 class=&amp;#39;post_link&amp;#39;&amp;gt;&amp;#34; 162 ,title||&amp;#34;無題&amp;#34;,&amp;#34;&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;&amp;#34; 163 ,&amp;#34;&amp;lt;div class=&amp;#39;post_meta&amp;#39;&amp;gt;&amp;lt;svg class=&amp;#39;icon&amp;#39;&amp;gt;&amp;lt;use xlink:href=&amp;#39;#calendar&amp;#39;&amp;gt;&amp;lt;/use&amp;gt;&amp;lt;/svg&amp;gt;&amp;lt;span class=&amp;#39;post_date&amp;#39;&amp;gt;&amp;#34; 164 ,ctime 165 ,&amp;#34;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#39;excerpt_footer&amp;#39;&amp;gt;&amp;lt;p&amp;gt;&amp;#34; 166 ,snippet(bodylist[num],idx,len) 167 ,&amp;#34;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/li&amp;gt;&amp;#34; 168 ); 169 } 170 } 171 re.innerHTML = buf.join(&amp;#34;&amp;#34;); 172} 173for(var i=0;i&amp;lt;data.length;i&#43;&#43;){ 174 bodylist.push(data[i].title&#43; &amp;#34; &amp;#34; &#43;data[i].content); 175} 176var bodyidx = bodylist.join(&amp;#34;&amp;lt;&amp;gt;&amp;#34;); 177&amp;lt;/script&amp;gt; 変更点 リスト項目部分 1buf.push( 2 &amp;#34;&amp;lt;li class=&amp;#39;post_item&amp;#39;&amp;gt;&amp;lt;div class=&amp;#39;excerpt&amp;#39;&amp;gt;&amp;lt;div class=&amp;#39;excerpt_header&amp;#39;&amp;gt;&amp;lt;a href=&amp;#39;&amp;#34;,url,&amp;#34;&amp;#39;&amp;gt;&amp;lt;h3 class=&amp;#39;post_link&amp;#39;&amp;gt;&amp;#34; 3 ,title||&amp;#34;無題&amp;#34;,&amp;#34;&amp;lt;/a&amp;gt;&amp;lt;/h3&amp;gt;&amp;#34; 4 ,&amp;#34;&amp;lt;div class=&amp;#39;post_meta&amp;#39;&amp;gt;&amp;lt;svg class=&amp;#39;icon&amp;#39;&amp;gt;&amp;lt;use xlink:href=&amp;#39;#calendar&amp;#39;&amp;gt;&amp;lt;/use&amp;gt;&amp;lt;/svg&amp;gt;&amp;lt;span class=&amp;#39;post_date&amp;#39;&amp;gt;&amp;#34; 5 ,ctime 6 ,&amp;#34;&amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&amp;#39;excerpt_footer&amp;#39;&amp;gt;&amp;lt;p&amp;gt;&amp;#34; 7 ,snippet(bodylist[num],idx,len) 8 ,&amp;#34;&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/li&amp;gt;&amp;#34; 9); これは、記事のリストのHTMLを作成する部分です。 自分の場合は、Clarityテーマの記事リストを再現するためにこのような構造になっていますが、各自編集してください。 url（記事URL）、title（記事名）、ctime（作成日）、snippet(bodylist[num],idx,len)（本文）です。 URLパラメータ 1const input = document.getElementById(&amp;#34;input&amp;#34;) 2window.history.replaceState(0, 0,&amp;#34;./?q=&amp;#34;&#43;input.value); ここでは、入力される度にURLパラメータを書き換えています。 4.URLパラメータの対応 1&amp;lt;script&amp;gt; 2 window.onload = function () { 3 const searchParams = new URLSearchParams(decodeURI(location.search)); 4 const param = searchParams.get(&amp;#39;q&amp;#39;); 5 var input = document.getElementById(&amp;#39;input&amp;#39;); 6 input.value = param; 7 do_find(input.value); 8 }; 9&amp;lt;/script&amp;gt; URLパラメータがあると、読み込み時に自動で検索されるスクリプトです。 5.CSSの適用 リスト部分は、テーマのHTMLを使いまわす事によってCSSも適用されるようになりました。あとは、以下の分を書き足せばいいと思います。 あくまで例なので、適宜書き換えてください。 1&amp;lt;style&amp;gt; 2 body { 3 background: var(--custom-bg); 4 } 5 h1 { 6 margin-left: 2%; 7 } 8 #searchbox { 9 margin-left: 2%; 10 margin-top: 10px; 11 margin-bottom: 10px; 12 } 13 input { 14 background: none; 15 border: none; 16 border-radius: 0; 17 outline: none; 18 -webkit-appearance: none; 19 -moz-appearance: none; 20 appearance: none; 21 max-width: 230px; 22 color:var(--text); 23 border-bottom:var(--header-text) 2px solid; 24 font-size: 30px; 25 margin-right: 5px; 26 } 27 b{ 28 color: #0077B8; 29 background-color: #D3E0EA; 30 font-weight: 600; 31 padding: 3px; 32 border-radius: 3px; 33 } 34 #navi { 35 font-size: 25px; 36 margin-left: 3%; 37 } 38 #navi span{ 39 border: 1px solid #0077B8; 40 padding: 0 0.5em; 41 cursor: pointer; 42 border-radius: 3px; 43 } 44 span.selected{ 45 color: #0077B8; 46 background : #D3E0EA; 47 } 48 .searchbar{ 49 display: none; 50 } 51&amp;lt;/style&amp;gt; ちなみに、非表示にしている.searchbarというのは、後述するサイドバーのボックスのことです。 6.サイドバーに検索ボックスを追加 サイドバーのHTML（Clarityテーマではthemes/テーマ名/layouts/partials/sidebar.html）をテーマ内ファイルから見つけて、 layouts/以下にコピーします。 そして、以下のdivを書き足してください。 1&amp;lt;div class=&amp;#34;searchbar&amp;#34;&amp;gt; 2 &amp;lt;h2&amp;gt;Search&amp;lt;/h2&amp;gt; 3 &amp;lt;input type=&amp;#34;text&amp;#34; id=&amp;#34;search&amp;#34; class=&amp;#34;search&amp;#34;/&amp;gt; 4 &amp;lt;script&amp;gt; 5 const input = document.getElementById(&amp;#34;search&amp;#34;); 6 input.addEventListener(&amp;#39;keypress&amp;#39;, (e) =&amp;gt; { 7 if (e.key === &amp;#39;Enter&amp;#39;) { 8 window.location.href = {{ absURL &amp;#34;search/&amp;#34; }} &#43; &amp;#34;?q=&amp;#34; &#43; encodeURI(input.value); 9 } 10 }); 11 &amp;lt;/script&amp;gt; 12&amp;lt;/div&amp;gt; おわりに 以上で完成です。 どちらかというとこの後のCSS調整の方が時間がかかると思いますが、 これでとりあえず動くところまでできたと思います。]"
}



,
{
url: "https://luke-1220.github.io/post/lastmod/",
title: "【Hugo】Robustテーマで記事を更新順に並べる",
ctime: "2020/08/04",
content: "[HugoのRobustテーマで記事を更新順に並べ、記事一覧に更新日を表示させる方法を紹介します。 はじめに Qiitaから引っ越した記事などにdateとlastmodを設定したのですが、記事一覧が作成日順になっているのが気になりました。 もし、昔書いた記事を大幅に書き換えて最新の内容にしたのに、作成日が古いせいで後ろの方に表示される、なんてことがあったら困ります。 そこで今回は、記事を更新順に並べてみます。 記事を更新順に並べる themes/hugo_theme_robust/layouts/_default/list.htmlを、layouts/_default/list.htmlにコピー。 1{{ range $paginator.Pages }} この部分（⌘Fで探してください）に書き足すだけです。 1{{ range $paginator.Pages.ByLastmod.Reverse }} .ByLastmodで更新日の古い順にし、.Reverseで新しい順に並び替えます。 追記 結局、記事一覧の方は作成日順に戻しました。 更新順にするのはLATESTSだけで良いかな…。 記事一覧に更新日を表示させる themes/hugo_theme_robust/layouts/_default/li_sm.htmlもlayouts/_default/li_sm.htmlにコピーします。 li_sm.htmlとlist.htmlから以下の一行を探し、 1&amp;lt;li&amp;gt;&amp;lt;i class=&amp;#34;fas fa-calendar&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;time datetime=&amp;#34;{{ .Date.Format &amp;#34;2007-01-02T15:04:05JST&amp;#34; }}&amp;#34;&amp;gt;{{ .Date.Format ( .Site.Params.dateformat | default &amp;#34;Jan 2, 2006&amp;#34;) }}&amp;lt;/time&amp;gt;&amp;lt;/li&amp;gt; 削除してから、このif文を丸ごとペーストしてください。 1{{ if ne .Date .Lastmod }} 2&amp;lt;li&amp;gt;&amp;lt;i class=&amp;#34;fas fa-sync&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;time datetime=&amp;#34;{{ .Lastmod.Format &amp;#34;2006-01-02T15:04:05JST&amp;#34; }}&amp;#34;&amp;gt;{{ .Lastmod.Format ( .Site.Params.dateformat | default &amp;#34;Jan 2, 2006&amp;#34;) }}&amp;lt;/time&amp;gt;&amp;lt;/li&amp;gt; 3{{ else }} 4&amp;lt;li&amp;gt;&amp;lt;i class=&amp;#34;fas fa-calendar&amp;#34; aria-hidden=&amp;#34;true&amp;#34;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;time datetime=&amp;#34;{{ .Date.Format &amp;#34;2006-01-02T15:04:05JST&amp;#34; }}&amp;#34;&amp;gt;{{ .Date.Format ( .Site.Params.dateformat | default &amp;#34;Jan 2, 2006&amp;#34;) }}&amp;lt;/time&amp;gt;&amp;lt;/li&amp;gt; 5{{ end }} これで、更新日がある場合はそちらが表示され、ない場合（または作成日と同じ場合）は作成日が表示されます。 ちなみに、li_sm.htmlがサイドバーの「LATESTS」や記事ページ下部の「次の記事」欄のHTMLファイルで、list.htmlはトップページやカテゴリページのためのHTMLファイルのようです。 参考 最近更新された記事（新着記事）のリストを表示する]"
}



,
{
url: "https://luke-1220.github.io/post/get-related-articles/",
title: "【Swift5】キーワードの重複で「関連記事」を取得してみる",
ctime: "2020/06/07",
content: "[今回は、ニュースアプリの記事ページの一番下にある「関連記事」を選ぶ関数を作ったので共有したいと思います。 使用するクラス 1class Entry: NSObject, NSCoding { 2 var title:String? 3 //省略 4} 自分のアプリでは、titleの他にURLなどのプロパティも持たせています。 完成品 1func getRelatedArticle(entry:Entry, entries:[Entry]) -&amp;gt; [Entry] { 2 3 let exempt = [&amp;#34;で&amp;#34;,&amp;#34;の&amp;#34;,&amp;#34;は&amp;#34;,&amp;#34;を&amp;#34;,&amp;#34;も&amp;#34;,&amp;#34;が&amp;#34;,&amp;#34;に&amp;#34;,&amp;#34;万&amp;#34;,&amp;#34;円&amp;#34;] 4 var words:[String] = [] 5 var counts:Dictionary&amp;lt;Entry,Int&amp;gt; = [:] 6 let checkEntries = entries.filter {$0 != entry} 7 8 let wordTokenizer = NLTokenizer(unit: .word) 9 wordTokenizer.string = entry.title 10 wordTokenizer.enumerateTokens(in: entry.title!.startIndex..&amp;lt;entry.title!.endIndex) { tokenRange, _ in 11 let word = String(entry.title![tokenRange]).localizedUppercase 12 if !exempt.contains(word) { 13 words.append(word) 14 print(word) 15 } 16 return true 17 } 18 //print(&amp;#34;contains:\(words)&amp;#34;) 19 20 for e in checkEntries { 21 var count = 0 22 let text = e.title! 23 wordTokenizer.string = text 24 wordTokenizer.enumerateTokens(in: text.startIndex..&amp;lt;text.endIndex) { tokenRange, _ in 25 //print( text[tokenRange]) 26 if words.contains(String(text[tokenRange].localizedUppercase)) { 27 count &#43;= 1 28 } 29 return true 30 } 31 counts.updateValue(count, forKey: e) 32 } 33 let sorted = Array(counts).sorted {$0.1 &amp;gt; $1.1}.prefix(3) 34 var related:[Entry] = [] 35 for (key,value) in (sorted) { 36 //print(&amp;#34;\(key.title!) 単語数:\(value)&amp;#34;) 37 related.append(key) 38 } 39 return related 40} 全ての記事名を単語に分解して、重複する単語が多かった記事を関連記事として選んでいます。 分解には標準ライブラリのNaturalLanguageを使っているので忘れずにimportしてください。 1import NaturalLanguage 使用例 1//nowEntry -&amp;gt; 今見ている記事 2//AllEntries -&amp;gt; 全ての記事の配列 3let related = getRelatedArticle(entry: nowEntry, entries: AllEntries) 4print(related.map({$0.title!})) 出力結果 この記事で実験してみました。 また、全記事のリストはいくつかニュースサイトのRSSから取得しています。 藤井七段「充実感が…」棋聖戦第一局に勝利 コメントアウトしてあるprintを使えばログで確認できます。 抽出した単語と、関連記事はこんな感じになりました。 contains:[&amp;quot;藤井&amp;quot;, &amp;quot;七&amp;quot;, &amp;quot;段&amp;quot;, &amp;quot;充実&amp;quot;, &amp;quot;感&amp;quot;, &amp;quot;棋聖&amp;quot;, &amp;quot;戦&amp;quot;, &amp;quot;第&amp;quot;, &amp;quot;一&amp;quot;, &amp;quot;局&amp;quot;, &amp;quot;勝利&amp;quot;, &amp;quot;6&amp;quot;, &amp;quot;8&amp;quot;, &amp;quot;21&amp;quot;, &amp;quot;33&amp;quot;, &amp;quot;更新&amp;quot;] 藤井七段、棋聖戦第一局で渡辺三冠に勝利 6/8 20:08更新 単語数:12 藤井七段が最年少で挑戦 「棋聖戦」始まる 6/8 12:05更新 単語数:8 経団連会長 第２次補正予算案を評価 6/8 21:48更新 単語数:5 藤井七段の他の記事は取得できているので、問題ありません。 ただ、やっぱり精度が微妙なので「この記事もオススメ」みたいな感じで表示させた方がいいかも。 補足、解説 1let exempt = [&amp;#34;で&amp;#34;,&amp;#34;の&amp;#34;,&amp;#34;は&amp;#34;,&amp;#34;を&amp;#34;,&amp;#34;も&amp;#34;,&amp;#34;が&amp;#34;,&amp;#34;に&amp;#34;,&amp;#34;万&amp;#34;,&amp;#34;円&amp;#34;] ここで除外する単語を指定しています。 英語のサイトでは「a」「the」「in」などのワードが余計でした。 後々、ひらがな一文字とアルファベット一文字を自動で除外できるようにしたい。 1for (key,value) in (Array(counts).sorted {$0.1 &amp;gt; $1.1}.prefix(3)) { 2 //print(&amp;#34;\(key.title!) 単語数:\(value)&amp;#34;) 3 related.append(key) 4} ここのprefix(3)を変更することで取得する記事の数が変更できます。 課題 この記事のタイトルのように括弧などの記号などが含まれていると単語が取得できない 参考 https://dev.classmethod.jp/articles/ios12-natural-language-tokenizing/]"
}



,
{
url: "https://luke-1220.github.io/post/pre-fill-form/",
title: "【Swift5】Googleフォームにあらかじめ自動入力する",
ctime: "2020/05/25",
content: "[アプリの不具合の報告などで、OS情報やアプリのバージョンなどの情報があるととても助かりますよね。 そこで今回は、それらの項目を自動入力してくれるフォームの作り方を紹介します。 方法 Googleフォームには、自動入力済みのURLを発行する機能があります。 このURLの一部をSwiftで書き換えればいいのです。 1. フォームを作成 こちらからフォームを作成してください。 作成方法については説明を割愛させていただきます。 2. URLを生成 フォーム作成画面の右上にある、・が縦に3つ並んだメニューボタンから、「事前入力したURLを取得」をクリックします。 するとフォーム入力画面に飛ぶので、事前入力しておきたい項目に分かりやすい文字列を入力しておきます。 「リンクを取得」をクリックするとURLが生成されます。 画面左下の「リンクをコピー」を押してコピーしておきましょう。 自分の場合はこのようなリンクになりました。 https://docs.google.com/forms/d/e/1FAIpQLScUGRP-Pbs0bpBw2MtwjN6OpxeoHgUjloGV-OMNVOBvEkLJ6A/viewform?usp=pp_url&amp;amp;entry.1009686721=osversion&amp;amp;entry.1835889012=appversion 3. OS情報、アプリのバージョンを取得 OS名はUIDevice.current.systemName、OSバージョンはUIDevice.current.systemVersionで取得可能です。（どちらもStringです） 1let os = &amp;#34;\(UIDevice.current.systemName)%20\(UIDevice.current.systemVersion)&amp;#34; 2let version = Bundle.main.object(forInfoDictionaryKey: &amp;#34;CFBundleShortVersionString&amp;#34;) as? String この文字列はURLの一部となるため、スペース（空白）は使ってはいけません。 代わりに%20を使用すると空白になります。 追記 機種の名前を取得する 正確な機種名（例えば「iPhone XS」など）を取得するため、YMTGetDeviceNameというライブラリを使用します。 1var device = YMTGetDeviceName.share.getDeviceName() 2if let devName = device.range(of: &amp;#34; &amp;#34;) { 3 device.replaceSubrange(devName, with: &amp;#34;%20&amp;#34;) 4} rangeを使って、空白を%20に置き換えています。 4. URLの書き換え 先ほどのURLのosversionの部分を\(os)に、appversionの部分を\(version)に書き換えるだけです。 1let url = URL(string:&amp;#34;https://docs.google.com/forms/d/e/1FAIpQLScUGRP-Pbs0bpBw2MtwjN6OpxeoHgUjloGV-OMNVOBvEkLJ6A/viewform?usp=pp_url&amp;amp;entry.1009686721=\(os)&amp;amp;entry.1835889012=\(version!)&amp;#34;) 2UIApplication.shared.open(url! as URL) 動作確認 問題なく表示されています。 ユーザーの手間を省けるので、試す価値はあると思います！]"
}



,
{
url: "https://luke-1220.github.io/post/original-class-save/",
title: "【Swift5】自作クラス（と配列）をUserDefaultsに簡単に保存する",
ctime: "2020/05/24",
content: "[この記事では自作クラスをUserDefaultsに簡単に保存する関数を紹介します。 ちょっとしたデータの保存はUserDefaultsを使うのが一般的ですが、保存できる型が限られています。 対応していない場合はDataに変換して保存する必要があり、少し面倒です。 そこで今回は関数（と言っても大したことはないですが）を作成しました。 保存したいクラス 1 class Friend: NSObject, NSCoding { 2 var name:String? 3 var age:Int? 4 5 init(_ name: String?, _age: Int?) { 6 self.name = name 7 self.age= age 8 } 9 10 func encode(with coder: NSCoder) { 11 coder.encode(name, forKey: &amp;#34;name&amp;#34;) 12 coder.encode(age, forKey: &amp;#34;age&amp;#34;) 13 } 14 15 required init?(coder: NSCoder) { 16 name = coder.decodeObject(forKey: &amp;#34;name&amp;#34;) as? String 17 age = coder.decodeObject(forKey: &amp;#34;age&amp;#34;) as? Int 18 } 19 } ポイントは１行目に: NSObject, NSCodingと加えることと、エンコード・デコードの部分を用意することです。 保存、取得用の関数 通常 1 extension UserDefaults { 2 func getFriend(_ key:String) -&amp;gt; Friend? { 3 if let storedData = UserDefaults.standard.object(forKey: key) as? Data { 4 if let unarchivedObject = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(storedData) as? Friend { 5 return unarchivedObject 6 } 7 } 8 return nil 9 } 10 11 func setFriend(_ friend:[Friend],_ key:String) { 12 let data = try! NSKeyedArchiver.archivedData(withRootObject: friend, requiringSecureCoding: false) 13 UserDefaults.standard.set(data, forKey: key) 14 } 15 } 配列の場合 1 extension UserDefaults { 2 func getFriends(_ key:String) -&amp;gt; [Friend]? { 3 if let storedData = self.object(forKey: key) as? Data { 4 if let unarchivedObject = try! NSKeyedUnarchiver.unarchiveTopLevelObjectWithData(storedData) as? [Friend] { 5 return unarchivedObject 6 } 7 } 8 return nil 9 } 10 11 func setFriends(_ friends:[Friend],_ key:String) { 12 let data = try! NSKeyedArchiver.archivedData(withRootObject: friends, requiringSecureCoding: false) 13 self.set(data, forKey: key) 14 } 15 } 使用方法 この関数はUserDefaultsの拡張なので、このように使います。 通常 1 let boy = Friend.init(&amp;#34;Tom&amp;#34;,25) 2 //保存 3 UserDefaults.standard.setFriend(boy,&amp;#34;friend&amp;#34;) 4 //取得 5 let friend = UserDefaults.standard.getFriend(&amp;#34;friend&amp;#34;) 配列の場合 1 let boys = [Friend.init(&amp;#34;Tom&amp;#34;,25),Friend.init(&amp;#34;Bob&amp;#34;,18)] 2 //保存 3 UserDefaults.standard.setFriends(boys,&amp;#34;friends&amp;#34;) 4 //取得 5 let friends = UserDefaults.standard.getFriends(&amp;#34;friends&amp;#34;) おわりに 通常のUserDefaultsのように１行で使えるので、コードが見やすくなると思います。 間違っている部分があったら教えていただけると助かります🙇‍♂️]"
}

]
